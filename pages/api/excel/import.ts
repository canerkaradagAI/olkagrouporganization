import type { NextApiRequest, NextApiResponse } from 'next'
import { PrismaClient } from '@prisma/client'
import formidable from 'formidable'
import * as XLSX from 'xlsx'
import fs from 'fs'

const prisma = new PrismaClient()

export const config = {
  api: {
    bodyParser: false,
  },
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' })
  }

  const form = formidable({ multiples: false })

  try {
    const [fields, files] = await form.parse(req)
    
    const file = files.file?.[0]
    const selectedTable = fields.table?.[0] as string || 'employee'

    if (!file) {
      return res.status(400).json({ message: 'Dosya bulunamadƒ±' })
    }

    console.log('üìä Excel import ba≈ülƒ±yor...')
    console.log('Selected table:', selectedTable)
    console.log('File path:', file.filepath)

    const filePath = file.filepath
    const workbook = XLSX.readFile(filePath)
    const sheetName = workbook.SheetNames[0]
    const sheet = workbook.Sheets[sheetName]
    const data: any[] = XLSX.utils.sheet_to_json(sheet)

    console.log(`üìä Excel dosyasƒ± okundu: ${data.length} satƒ±r`)

    // Import data
    let importedCount = 0
    const errors: string[] = []
    
    if (selectedTable === 'company') {
      console.log('üè¢ Company import ba≈ülƒ±yor...')
      for (const row of data) {
        const companyName = (row.CompanyName || row.companyName || '').toString().trim()
        if (companyName) {
          await prisma.company.create({ data: { companyName } })
          importedCount++
        }
      }
    } else if (selectedTable === 'brand') {
      console.log('üè¢ Brand import ba≈ülƒ±yor...')
      const company = await prisma.company.upsert({
        where: { companyName: 'Olka Group' },
        update: {},
        create: { companyName: 'Olka Group' },
      })
      for (const row of data) {
        const brandName = (row.BrandName || row.brandName || '').toString().trim()
        if (brandName) {
          await prisma.brand.create({ data: { brandName, companyId: company.companyId } })
          importedCount++
        }
      }
    } else if (selectedTable === 'location') {
      console.log('üìç Location import ba≈ülƒ±yor...')
      for (const row of data) {
        const locationName = (row.LocationName || row.locationName || '').toString().trim()
        if (locationName) {
          await prisma.location.create({ data: { locationName } })
          importedCount++
        }
      }
    } else if (selectedTable === 'department') {
      console.log('üè¢ Department import ba≈ülƒ±yor...')
      for (const row of data) {
        const departmentName = (row.DepartmentName || row.departmentName || '').toString().trim()
        if (departmentName) {
          await prisma.department.create({ data: { departmentName } })
          importedCount++
        }
      }
    } else if (selectedTable === 'position') {
      console.log('üíº Position import ba≈ülƒ±yor...')
      for (const row of data) {
        const positionName = (row.PositionName || row.positionName || '').toString().trim()
        if (positionName) {
          await prisma.position.create({ data: { positionName } })
          importedCount++
        }
      }
    } else if (selectedTable === 'jobtitlelevel') {
      console.log('üìä JobTitleLevel import ba≈ülƒ±yor...')
      for (const row of data) {
        const levelName = (row.LevelName || row.levelName || '').toString().trim()
        const levelOrder = parseInt(row.LevelOrder || row.levelOrder || '0')
        const description = (row.Description || row.description || '').toString().trim()
        if (levelName) {
          await prisma.jobTitleLevel.create({
            data: {
              levelName,
              levelOrder: levelOrder > 0 ? levelOrder : undefined,
              description: description || `${levelName} seviyesi`
            }
          })
          importedCount++
        }
      }
    } else if (selectedTable === 'employee') {
      console.log('üë• Employee import ba≈ülƒ±yor...')
      
      // Unique deƒüerleri topla
      const uniqueBrands = new Map<string, number>()
      const uniqueLocations = new Map<string, number>()
      const uniqueDepartments = new Map<string, number>()
      const uniquePositions = new Map<string, number>()
      const uniqueLevels = new Map<string, number>()
      
      let brandCounter = 1
      let locationCounter = 1
      let departmentCounter = 1
      let positionCounter = 1
      let levelCounter = 1

      // ƒ∞lk ge√ßi≈ü: Unique deƒüerleri topla
      console.log('üìä Unique deƒüerler toplanƒ±yor...')
      for (const row of data) {
        const brandName = (row.BrandName || row.brandName || '').toString().trim()
        const locationName = (row.LocationName || row.locationName || '').toString().trim()
        const departmentName = (row.DepartmentName || row.departmentName || '').toString().trim()
        const positionName = (row.PositionName || row.positionName || '').toString().trim()
        const levelName = (row.LevelName || row.levelName || '').toString().trim()

        if (brandName && !uniqueBrands.has(brandName)) {
          uniqueBrands.set(brandName, brandCounter++)
        }
        if (locationName && !uniqueLocations.has(locationName)) {
          uniqueLocations.set(locationName, locationCounter++)
        }
        if (departmentName && !uniqueDepartments.has(departmentName)) {
          uniqueDepartments.set(departmentName, departmentCounter++)
        }
        if (positionName && !uniquePositions.has(positionName)) {
          uniquePositions.set(positionName, positionCounter++)
        }
        if (levelName && !uniqueLevels.has(levelName)) {
          uniqueLevels.set(levelName, levelCounter++)
        }
      }

      // Company olu≈ütur
      const company = await prisma.company.upsert({
        where: { companyName: 'Olka Group' },
        update: {},
        create: { companyName: 'Olka Group' },
      })

      // Brand'leri olu≈ütur
      console.log('üè¢ Brand\'ler olu≈üturuluyor...')
      const brandIdMap = new Map<string, number>()
      for (const [brandName, id] of uniqueBrands) {
        const brand = await prisma.brand.upsert({
          where: { brandName: brandName },
          update: { companyId: company.companyId },
          create: {
            brandName: brandName,
            companyId: company.companyId
          }
        })
        brandIdMap.set(brandName, brand.brandId)
      }

      // Location'larƒ± olu≈ütur
      console.log('üìç Location\'lar olu≈üturuluyor...')
      const locationIdMap = new Map<string, number>()
      for (const [locationName, id] of uniqueLocations) {
        const location = await prisma.location.upsert({
          where: { locationName: locationName },
          update: {},
          create: { locationName: locationName }
        })
        locationIdMap.set(locationName, location.locationId)
      }

      // Department'leri olu≈ütur
      console.log('üè¢ Department\'ler olu≈üturuluyor...')
      const departmentIdMap = new Map<string, number>()
      for (const [departmentName, id] of uniqueDepartments) {
        const department = await prisma.department.upsert({
          where: { departmentName: departmentName },
          update: {},
          create: { departmentName: departmentName }
        })
        departmentIdMap.set(departmentName, department.departmentId)
      }

      // JobTitleLevel'leri olu≈ütur
      console.log('üìä JobTitleLevel\'ler olu≈üturuluyor...')
      const levelIdMap = new Map<string, number>()
      for (const [levelName, id] of uniqueLevels) {
        const level = await prisma.jobTitleLevel.upsert({
          where: { levelName: levelName },
          update: {},
          create: {
            levelName: levelName,
            levelOrder: id,
            description: `${levelName} seviyesi`
          }
        })
        levelIdMap.set(levelName, level.levelId)
      }

      // Position'larƒ± olu≈ütur
      console.log('üíº Position\'lar olu≈üturuluyor...')
      const positionIdMap = new Map<string, number>()
      for (const [positionName, id] of uniquePositions) {
        // √ñnce mevcut position'ƒ± kontrol et
        let position = await prisma.position.findFirst({
          where: { positionName: positionName }
        })
        
        // Yoksa olu≈ütur
        if (!position) {
          position = await prisma.position.create({
            data: {
              positionName: positionName,
            }
          })
        }
        
        positionIdMap.set(positionName, position.positionId)
      }

      // Employee'leri olu≈ütur - ƒ∞lk a≈üama: ManagerId olmadan
      console.log('üë• Employee\'ler olu≈üturuluyor (1. a≈üama - ManagerId olmadan)...')
      console.log(`üìä Toplam ${data.length} satƒ±r i≈ülenecek`)
      
      for (const row of data) {
        try {
          const currAccCode = (row.CurrAccCode || row.currAccCode || '').toString().trim()
          const nameSurname = (row.NameSurname || row.nameSurname || '').toString().trim()
          const brandName = (row.BrandName || row.brandName || '').toString().trim()
          const locationName = (row.LocationName || row.locationName || '').toString().trim()
          const departmentName = (row.DepartmentName || row.departmentName || '').toString().trim()
          const positionName = (row.PositionName || row.positionName || '').toString().trim()
          const managerId = (row.ManagerId || row.managerId || '').toString().trim() || null
          const levelName = (row.LevelName || row.levelName || '').toString().trim() || null
          const isManager = String(row.IsManager || row.isManager || '').toLowerCase() === 'true'

          console.log(`üîç Satƒ±r ${importedCount + 1}: CurrAccCode="${currAccCode}", NameSurname="${nameSurname}"`)

          if (!currAccCode || !nameSurname) {
            console.log(`‚ùå Satƒ±r ${importedCount + 1}: CurrAccCode veya NameSurname bo≈ü - ATLANIYOR`)
            errors.push(`Satƒ±r ${importedCount + 1}: CurrAccCode veya NameSurname bo≈ü`)
            continue
          }

          // ID'leri bul - eƒüer yoksa olu≈ütur
          console.log(`üîç Arama: brandName="${brandName}", locationName="${locationName}", departmentName="${departmentName}", positionName="${positionName}"`)
          console.log(`üîç BrandIdMap keys:`, Array.from(brandIdMap.keys()))
          
          let brandId = brandName ? brandIdMap.get(brandName) : null
          let locationId = locationName ? locationIdMap.get(locationName) : null
          let departmentId = departmentName ? departmentIdMap.get(departmentName) : null
          let positionId = positionName ? positionIdMap.get(positionName) : null
          
          console.log(`üîç Bulunan ID'ler: brandId=${brandId}, locationId=${locationId}, departmentId=${departmentId}, positionId=${positionId}`)

          // Eksik kayƒ±tlarƒ± olu≈ütur
          if (brandName && !brandId) {
            console.log(`‚ö†Ô∏è Brand bulunamadƒ±, olu≈üturuluyor: ${brandName}`)
            const newBrand = await prisma.brand.create({
              data: {
                brandName: brandName,
                companyId: company.companyId
              }
            })
            brandId = newBrand.brandId
            brandIdMap.set(brandName, brandId)
          }

          if (locationName && !locationId) {
            console.log(`‚ö†Ô∏è Location bulunamadƒ±, olu≈üturuluyor: ${locationName}`)
            const newLocation = await prisma.location.create({
              data: { locationName: locationName }
            })
            locationId = newLocation.locationId
            locationIdMap.set(locationName, locationId)
          }

          if (departmentName && !departmentId) {
            console.log(`‚ö†Ô∏è Department bulunamadƒ±, olu≈üturuluyor: ${departmentName}`)
            const newDepartment = await prisma.department.create({
              data: { departmentName: departmentName }
            })
            departmentId = newDepartment.departmentId
            departmentIdMap.set(departmentName, departmentId)
          }

          if (positionName && !positionId) {
            console.log(`‚ö†Ô∏è Position bulunamadƒ±, olu≈üturuluyor: ${positionName}`)
            const newPosition = await prisma.position.create({
              data: { positionName: positionName }
            })
            positionId = newPosition.positionId
            positionIdMap.set(positionName, positionId)
          }

          console.log(`üíæ Employee olu≈üturuluyor: ${currAccCode} - ${nameSurname}`)
          console.log(`   BrandId: ${brandId}, LocationId: ${locationId}, DepartmentId: ${departmentId}, PositionId: ${positionId}`)

          // ƒ∞lk a≈üamada ManagerId'yi null yap (ikinci a≈üamada g√ºncellenecek)
          const validManagerId = null

          // Mevcut √ßalƒ±≈üanƒ± kontrol et (upsert yerine create kullanmak i√ßin)
          const existingEmployee = await prisma.employee.findUnique({
            where: { currAccCode: currAccCode }
          });

          if (existingEmployee) {
            // Eƒüer √ßalƒ±≈üan zaten varsa, g√ºncelle
            await prisma.employee.update({
              where: { currAccCode: currAccCode },
              data: {
                firstLastName: nameSurname,
                organization: 'Olka Group',
                brandId: brandId,
                locationId: locationId,
                departmentId: departmentId,
                positionId: positionId,
                managerId: validManagerId,
                isManager: isManager,
                levelName: levelName,
              }
            });
            console.log(`üîÑ Employee g√ºncellendi: ${currAccCode}`);
          } else {
            // √áalƒ±≈üan yoksa, olu≈ütur
            await prisma.employee.create({
              data: {
                currAccCode,
                firstLastName: nameSurname,
                organization: 'Olka Group',
                brandId: brandId,
                locationId: locationId,
                departmentId: departmentId,
                positionId: positionId,
                managerId: validManagerId,
                isManager: isManager,
                levelName: levelName,
              }
            });
            console.log(`‚úÖ Employee olu≈üturuldu: ${currAccCode}`);
          }

          importedCount++
        } catch (error: any) {
          console.error(`‚ùå Employee olu≈üturma hatasƒ± (Satƒ±r ${importedCount + 1}):`, error.message)
          errors.push(`Satƒ±r ${importedCount + 1}: ${error.message}`)
        }
      }

      // ƒ∞kinci a≈üama: ManagerId'leri g√ºncelle
      console.log('üë• ManagerId\'ler g√ºncelleniyor (2. a≈üama)...')
      let managerUpdateCount = 0
      
      for (const row of data) {
        try {
          const currAccCode = (row.CurrAccCode || row.currAccCode || '').toString().trim()
          const managerId = (row.ManagerId || row.managerId || '').toString().trim()
          
          if (currAccCode && managerId) {
            // Manager'ƒ±n var olup olmadƒ±ƒüƒ±nƒ± kontrol et
            const managerExists = await prisma.employee.findUnique({
              where: { currAccCode: managerId }
            })
            
            if (managerExists) {
              // Employee'yi g√ºncelle
              await prisma.employee.update({
                where: { currAccCode: currAccCode },
                data: { managerId: managerId }
              })
              console.log(`üîÑ ManagerId g√ºncellendi: ${currAccCode} -> ${managerId}`)
              managerUpdateCount++
            } else {
              console.log(`‚ö†Ô∏è Manager bulunamadƒ±: ${managerId} (Employee: ${currAccCode})`)
            }
          }
        } catch (error: any) {
          console.error(`‚ùå ManagerId g√ºncelleme hatasƒ±: ${error.message}`)
        }
      }
      
      console.log(`‚úÖ ManagerId g√ºncelleme tamamlandƒ±: ${managerUpdateCount} kayƒ±t`)
    }

    console.log(`‚úÖ Import tamamlandƒ±: ${importedCount} kayƒ±t`)

    res.status(200).json({
      message: `${importedCount} kayƒ±t ba≈üarƒ±yla i√ße aktarƒ±ldƒ±`,
      importedCount,
      errors: errors.slice(0, 10)
    })

  } catch (error: any) {
    console.error('Excel import hatasƒ±:', error)
    res.status(500).json({ message: 'Import hatasƒ±: ' + error.message })
  } finally {
    await prisma.$disconnect()
  }
}
